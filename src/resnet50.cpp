#include <napi.h>

// code below copied and modified from:
// https://github.com/pytorch/glow/blob/master/examples/bundles/resnet50/resnet50.cpp

/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include <stdio.h>
#include <assert.h>
#include <stdlib.h>

#define DEFAULT_WIDTH 224
#define DEFAULT_HEIGHT 224

//===----------------------------------------------------------------------===//
//                 Wrapper code for executing a bundle
//===----------------------------------------------------------------------===//

// Type describing a symbol table entry of a generated bundle.
struct SymbolTableEntry {
  const char *name;
  size_t offset;
  size_t size;
  char kind;
};

// Type describing the config of a generated bundle.
struct BundleConfig {
  size_t constantWeightVarsMemSize;
  size_t mutableWeightVarsMemSize;
  size_t activationsMemSize;
  size_t alignment;
  size_t numSymbols;
  const SymbolTableEntry *symbolTable;
};

// These two external symbols are auto-generated by means of the -bundle option.
extern "C" void resnet50(uint8_t *constantWeightVars, uint8_t *mutableWeightVars, uint8_t *activations);
extern "C" BundleConfig resnet50_config;

// Find in the bundle's symbol table a weight variable whose name starts with \p name.
const SymbolTableEntry *getWeightVar(const BundleConfig &config, const char *name) {
  for (unsigned i = 0, e = config.numSymbols; i < e; ++i) {
    if (!strncmp(config.symbolTable[i].name, name, strlen(name))) {
      return &config.symbolTable[i];
    }
  }
  return nullptr;
}

// Find in the bundle's symbol table a mutable weight variable whose name starts with \p name.
const SymbolTableEntry &getMutableWeightVar(const BundleConfig &config, const char *name) {
  const SymbolTableEntry *mutableWeightVar = getWeightVar(config, name);
  if (!mutableWeightVar) {
    printf("Expected to find variable '%s'\n", name);
  }
  assert(mutableWeightVar && "Expected to find a mutable weight variable");
  assert(mutableWeightVar->kind != 0 && "Weight variable is expected to be mutable");
  return *mutableWeightVar;
}

// Allocate an aligned block of memory.
void *alignedAlloc(const BundleConfig &config, size_t size) {
  const size_t alignment = 64;
  void *ptr;
  // Properly align the memory region.
  int res = posix_memalign(&ptr, config.alignment, size);
  assert(res == 0 && "posix_memalign failed");
  assert((size_t)ptr % alignment == 0 && "Wrong alignment");
  memset(ptr, 0, size);
  return ptr;
}

// Initialize the constant weights memory block by loading the weights from the weights file.
static uint8_t *initConstantWeights(const char *weightsFileName, const BundleConfig &config) {
  // Load weights.
  FILE *weightsFile = fopen(weightsFileName, "rb");
  if (!weightsFile) {
    fprintf(stderr, "Could not open the weights file: %s\n", weightsFileName);
    exit(1);
  }
  fseek(weightsFile, 0, SEEK_END);
  size_t fileSize = ftell(weightsFile);
  fseek(weightsFile, 0, SEEK_SET);
  uint8_t *baseConstantWeightVarsAddr = static_cast<uint8_t *>(alignedAlloc(config, fileSize));
  //printf("Allocated weights of size: %lu\n", fileSize);
  //printf("Expected weights of size: %lu\n", config.constantWeightVarsMemSize);
  assert(fileSize == config.constantWeightVarsMemSize && "Wrong weights file size");
  int result = fread(baseConstantWeightVarsAddr, fileSize, 1, weightsFile);
  if (result != 1) {
    perror("Could not read the weights file");
  } else {
    //printf("Loaded weights of size: %lu from the file %s\n", fileSize, weightsFileName);
  }
  fclose(weightsFile);
  return baseConstantWeightVarsAddr;
}

// The assumed layout of the area for mutable WeightVars is: data | gpu_0/data | results
static uint8_t *allocateMutableWeightVars(const BundleConfig &config) {
  auto *weights = static_cast<uint8_t *>(alignedAlloc(config, config.mutableWeightVarsMemSize));
  //printf("Allocated mutable weight variables of size: %lu\n", config.mutableWeightVarsMemSize);
  return weights;
}

// Dump the result of the inference by looking at the results vector and finding the index of the max element.
static int dumpInferenceResults(const BundleConfig &config, uint8_t *mutableWeightVars) {
  const SymbolTableEntry &outputWeights = getMutableWeightVar(config, "output");
  int maxIdx = 0;
  float maxValue = 0;
  float *results = (float *)(mutableWeightVars + outputWeights.offset);
  for (int i = 0; i < int(outputWeights.size); ++i) {
    if (results[i] > maxValue) {
      maxValue = results[i];
      maxIdx = i;
    }
  }
  return maxIdx;
}

static uint8_t *initActivations(const BundleConfig &config) {
  return static_cast<uint8_t *>(alignedAlloc(config, config.activationsMemSize));
}

//------------------------------------------------------------------------------
// This is the bit that gets it to work in nodejs
//------------------------------------------------------------------------------

Napi::Value Resnet(const Napi::CallbackInfo& info) {
  Napi::Env env = info.Env();

  // input is in RGBA values between 0 and 255, we need to convert to a tensor
  // of dimensions [3, 224, 224] BGR floats between 0 and 1.
  Napi::Uint8Array buffer = info[0].As<Napi::Uint8Array>();

  size_t imageDataSizeInBytes = 3 * DEFAULT_WIDTH * DEFAULT_HEIGHT * sizeof(float);
  float *input = static_cast<float *>(malloc(imageDataSizeInBytes));
  for (int i = 0; i < DEFAULT_WIDTH * DEFAULT_HEIGHT && i < int(buffer.ElementLength() / 4); i++) {
    input[i] = float(buffer[i * 4 + 2]) / 255.0;
    input[DEFAULT_WIDTH * DEFAULT_HEIGHT + i] = float(buffer[i * 4 + 1]) / 255.0;
    input[2 * DEFAULT_WIDTH * DEFAULT_HEIGHT + i] = float(buffer[i * 4]) / 255.0;
  }

  uint8_t *constantWeightVarsAddr = initConstantWeights("lib/resnet50.weights", resnet50_config);

  uint8_t *mutableWeightVarsAddr = allocateMutableWeightVars(resnet50_config);
  const SymbolTableEntry &inputGPUDataVar = getMutableWeightVar(resnet50_config, "gpu_0_data");
  memcpy(mutableWeightVarsAddr + inputGPUDataVar.offset, input, imageDataSizeInBytes);

  uint8_t *activationsAddr = initActivations(resnet50_config);

  // Perform the computation.
  resnet50(constantWeightVarsAddr, mutableWeightVarsAddr, activationsAddr);

  // Report the results.
  int result = dumpInferenceResults(resnet50_config, mutableWeightVarsAddr);

  // Free all resources.
  free(activationsAddr);
  free(constantWeightVarsAddr);
  free(mutableWeightVarsAddr);

  return Napi::Number::New(env, result);
}

Napi::Object Init(Napi::Env env, Napi::Object exports) {
  exports.Set(Napi::String::New(env, "resnet"), Napi::Function::New(env, Resnet));
  return exports;
}

NODE_API_MODULE(resnet, Init)
